

Old friends....


If a socket uses the same fd for read an write, how does write know where to go?

In Assembly a write system call is a single instruction????


KERNEL 

The kernel infuses a lot more code than is visible in user space.
The operating system lives in user-space, as all the processes we deal with.
So, actually holds the file descriptor table with info of buffers, type of fd (pipe, socket, file, etc)?
It is the KERNEL.


When we write a program and do objdump, we only see the code that is visible in user-space, that is, the instructions
done without the execution of system calls underneath.

The file descriptor table lives in kernel space and not in the operating system.

On the other hand, malloc is used such that the operating system keeps track of memory pages but essentially you are bound
by the kernel via mmap and brk system calls.

It is also the kernel that implements the network transport protocols, not the operating system.

So socket internally does all of that, via kernel.

In user-space, we don't see the actual code that is running to fulfill such system calls, only the code that is executed in user space
and not in kernel space.




For our intents and purposes, if fds are non-blockin we can use read-write instead of send-recv, althought they allow fds to be blocking
but read and write in non-block mode, on a per-call basis (MAN)