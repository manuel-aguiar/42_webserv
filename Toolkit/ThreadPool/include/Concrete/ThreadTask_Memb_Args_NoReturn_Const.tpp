/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ThreadTask_Memb_Args_NoReturn_Const.tpp            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mmaria-d <mmaria-d@student.42lisboa.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/06 11:24:32 by mmaria-d          #+#    #+#             */
/*   Updated: 2024/10/09 08:31:38 by mmaria-d         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef THREADTASK_MEMB_ARGS_NORETURN_CONST_TPP

# define THREADTASK_MEMB_ARGS_NORETURN_CONST_TPP

# include <pthread.h>
# include <iostream>
# include <cstring>
# include <cassert>

# include "../Abstract/IThreadTask.hpp"
# include <vector>


/*
	Specializations for non member function that take up to 5 arguments and returns

	expansion generated by chatgpt (thanks, saved me hours.....)
*/

template <
	typename FunctionPointer
>
class ThreadTask;



template <
	typename Class,
	typename Args
>
class ThreadTask<void (Class::*)(Args) const> : public IThreadTask
{
	public:
		ThreadTask(const Class& instance, void (Class::*function)(Args) const , Args arguments) :
			m_instance(instance),
			m_function(function),
			m_args(arguments)
		{};
		~ThreadTask() {};
		ThreadTask(const ThreadTask& copy) :
			m_instance(copy.m_instance),
			m_function(copy.m_function),
			m_args(copy.m_args)
		{};
		ThreadTask& operator=(const ThreadTask& assign)
		{
			if (this == &assign)
				return (*this);
			*this = assign;
			return (*this);
		}

		void			execute() const
		{
			if (!m_function)
				return ;
			(m_instance.*m_function)(m_args);
		};
		IThreadTask*	clone() const
		{
			return (new ThreadTask(*this));
		};

	private:
		const Class&		    m_instance;
		void			        (Class::*m_function)(Args) const;
		Args			        m_args;
};


template <
	typename Class,
	typename Arg1,
	typename Arg2
>
class ThreadTask<void (Class::*)(Arg1, Arg2) const> : public IThreadTask
{
public:
	ThreadTask(const Class& instance, void (Class::*function)(Arg1, Arg2) const, Arg1 arg1, Arg2 arg2) :
		m_instance(instance),
		m_function(function),
		m_arg1(arg1),
		m_arg2(arg2)
	{}
	~ThreadTask() {}
	ThreadTask(const ThreadTask& copy) :
		m_instance(copy.m_instance),
		m_function(copy.m_function),
		m_arg1(copy.m_arg1),
		m_arg2(copy.m_arg2)
	{}
	ThreadTask& operator=(const ThreadTask& assign)
	{
		if (this == &assign)
			return *this;
		m_instance = assign.m_instance;
		m_function = assign.m_function;
		m_arg1 = assign.m_arg1;
		m_arg2 = assign.m_arg2;
		return *this;
	}

	void execute() const
	{
		if (!m_function)
			return;
		(m_instance.*m_function)(m_arg1, m_arg2);
	}

	IThreadTask* clone() const
	{
		return new ThreadTask(*this);
	}

private:
	const Class& m_instance;
	void (Class::*m_function)(Arg1, Arg2) const;
	Arg1 m_arg1;
	Arg2 m_arg2;
};



template <
	typename Class,
	typename Arg1,
	typename Arg2,
	typename Arg3
>
class ThreadTask<void (Class::*)(Arg1, Arg2, Arg3) const> : public IThreadTask
{
public:
	ThreadTask(const Class& instance, void (Class::*function)(Arg1, Arg2, Arg3) const, Arg1 arg1, Arg2 arg2, Arg3 arg3) :
		m_instance(instance),
		m_function(function),
		m_arg1(arg1),
		m_arg2(arg2),
		m_arg3(arg3)
	{}
	~ThreadTask() {}
	ThreadTask(const ThreadTask& copy) :
		m_instance(copy.m_instance),
		m_function(copy.m_function),
		m_arg1(copy.m_arg1),
		m_arg2(copy.m_arg2),
		m_arg3(copy.m_arg3)
	{}
	ThreadTask& operator=(const ThreadTask& assign)
	{
		if (this == &assign)
			return *this;
		m_instance = assign.m_instance;
		m_function = assign.m_function;
		m_arg1 = assign.m_arg1;
		m_arg2 = assign.m_arg2;
		m_arg3 = assign.m_arg3;
		return *this;
	}

	void execute() const
	{
		if (!m_function)
			return;
		(m_instance.*m_function)(m_arg1, m_arg2, m_arg3);
	}

	IThreadTask* clone() const
	{
		return new ThreadTask(*this);
	}

private:
	const Class& m_instance;
	void (Class::*m_function)(Arg1, Arg2, Arg3) const;
	Arg1 m_arg1;
	Arg2 m_arg2;
	Arg3 m_arg3;
};



template <
	typename Class,
	typename Arg1,
	typename Arg2,
	typename Arg3,
	typename Arg4
>
class ThreadTask<void (Class::*)(Arg1, Arg2, Arg3, Arg4) const> : public IThreadTask
{
public:
	ThreadTask(const Class& instance, void (Class::*function)(Arg1, Arg2, Arg3, Arg4) const, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) :
		m_instance(instance),
		m_function(function),
		m_arg1(arg1),
		m_arg2(arg2),
		m_arg3(arg3),
		m_arg4(arg4)
	{}
	~ThreadTask() {}
	ThreadTask(const ThreadTask& copy) :
		m_instance(copy.m_instance),
		m_function(copy.m_function),
		m_arg1(copy.m_arg1),
		m_arg2(copy.m_arg2),
		m_arg3(copy.m_arg3),
		m_arg4(copy.m_arg4)
	{}
	ThreadTask& operator=(const ThreadTask& assign)
	{
		if (this == &assign)
			return *this;
		m_instance = assign.m_instance;
		m_function = assign.m_function;
		m_arg1 = assign.m_arg1;
		m_arg2 = assign.m_arg2;
		m_arg3 = assign.m_arg3;
		m_arg4 = assign.m_arg4;
		return *this;
	}

	void execute() const
	{
		if (!m_function)
			return;
		(m_instance.*m_function)(m_arg1, m_arg2, m_arg3, m_arg4);
	}

	IThreadTask* clone() const
	{
		return new ThreadTask(*this);
	}

private:
	const Class& m_instance;
	void (Class::*m_function)(Arg1, Arg2, Arg3, Arg4) const;
	Arg1 m_arg1;
	Arg2 m_arg2;
	Arg3 m_arg3;
	Arg4 m_arg4;
};


template <
	typename Class,
	typename Arg1,
	typename Arg2,
	typename Arg3,
	typename Arg4,
	typename Arg5
>
class ThreadTask<void (Class::*)(Arg1, Arg2, Arg3, Arg4, Arg5) const> : public IThreadTask
{
public:
	ThreadTask(const Class& instance, void (Class::*function)(Arg1, Arg2, Arg3, Arg4, Arg5) const, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) :
		m_instance(instance),
		m_function(function),
		m_arg1(arg1),
		m_arg2(arg2),
		m_arg3(arg3),
		m_arg4(arg4),
		m_arg5(arg5)
	{}
	~ThreadTask() {}
	ThreadTask(const ThreadTask& copy) :
		m_instance(copy.m_instance),
		m_function(copy.m_function),
		m_arg1(copy.m_arg1),
		m_arg2(copy.m_arg2),
		m_arg3(copy.m_arg3),
		m_arg4(copy.m_arg4),
		m_arg5(copy.m_arg5)
	{}
	ThreadTask& operator=(const ThreadTask& assign)
	{
		if (this == &assign)
			return *this;
		m_instance = assign.m_instance;
		m_function = assign.m_function;
		m_arg1 = assign.m_arg1;
		m_arg2 = assign.m_arg2;
		m_arg3 = assign.m_arg3;
		m_arg4 = assign.m_arg4;
		m_arg5 = assign.m_arg5;
		return *this;
	}

	void execute() const
	{
		if (!m_function)
			return;
		(m_instance.*m_function)(m_arg1, m_arg2, m_arg3, m_arg4, m_arg5);
	}

	IThreadTask* clone() const
	{
		return new ThreadTask(*this);
	}

private:
	const Class& m_instance;
	void (Class::*m_function)(Arg1, Arg2, Arg3, Arg4, Arg5) const;
	Arg1 m_arg1;
	Arg2 m_arg2;
	Arg3 m_arg3;
	Arg4 m_arg4;
	Arg5 m_arg5;
};




#endif