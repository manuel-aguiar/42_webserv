/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ThreadTask_Memb_Args_Return_Const.tpp              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mmaria-d <mmaria-d@student.42lisboa.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/06 11:03:40 by mmaria-d          #+#    #+#             */
/*   Updated: 2024/12/26 12:23:17 by mmaria-d         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef THREADTASK_MEMB_ARGS_RETURN_CONST_TPP

# define THREADTASK_MEMB_ARGS_RETURN_CONST_TPP

# include <pthread.h>
# include <iostream>
# include <cstring>
# include <cassert>

# include "IThreadTask.hpp"
# include <vector>


/*
    Specializations for non member function that take up to 5 arguments and returns

    expansion generated by chatgpt (thanks, saved me hours.....)
*/

template <
	typename FunctionPointer
>
class ThreadTask;

// Specialization for const member function with 1 argument and a return
template <
	typename Class,
	typename Arg1,
	typename Return
>
class ThreadTask<Return (Class::*)(Arg1) const> : public IThreadTask
{
	public:
		ThreadTask(const Class& instance, Return (Class::*function)(Arg1) const, Arg1 arg1, Return* placeReturn = NULL) :
			m_instance(instance),
			m_function(function),
			m_arg1(arg1),
			m_placeReturn(placeReturn)
		{};
		~ThreadTask() {};
		ThreadTask(const ThreadTask& copy) :
			m_instance(copy.m_instance),
			m_function(copy.m_function),
			m_arg1(copy.m_arg1),
			m_placeReturn(copy.m_placeReturn)
		{};
		ThreadTask& operator=(const ThreadTask& assign)
		{
			if (this == &assign)
				return (*this);
			*this = assign;
			return (*this);
		}

		void execute() const
		{
			if (!m_function) return;
			if (m_placeReturn)
				*m_placeReturn = (m_instance.*m_function)(m_arg1);
			else
				(m_instance.*m_function)(m_arg1);
		}


	private:
		const Class& m_instance;
		Return (Class::*m_function)(Arg1) const;
		Arg1 m_arg1;
		Return* m_placeReturn;
};

// Specialization for const member function with 2 arguments and a return
template <
	typename Class,
	typename Arg1, typename Arg2,
	typename Return
>
class ThreadTask<Return (Class::*)(Arg1, Arg2) const> : public IThreadTask
{
	public:
		ThreadTask(const Class& instance, Return (Class::*function)(Arg1, Arg2) const, Arg1 arg1, Arg2 arg2, Return* placeReturn = NULL) :
			m_instance(instance),
			m_function(function),
			m_arg1(arg1),
			m_arg2(arg2),
			m_placeReturn(placeReturn)
		{};
		~ThreadTask() {};
		ThreadTask(const ThreadTask& copy) :
			m_instance(copy.m_instance),
			m_function(copy.m_function),
			m_arg1(copy.m_arg1),
			m_arg2(copy.m_arg2),
			m_placeReturn(copy.m_placeReturn)
		{};
		ThreadTask& operator=(const ThreadTask& assign)
		{
			if (this == &assign)
				return (*this);
			*this = assign;
			return (*this);
		}

		void execute() const
		{
			if (!m_function) return;
			if (m_placeReturn)
				*m_placeReturn = (m_instance.*m_function)(m_arg1, m_arg2);
			else
				(m_instance.*m_function)(m_arg1, m_arg2);
		}


	private:
		const Class& m_instance;
		Return (Class::*m_function)(Arg1, Arg2) const;
		Arg1 m_arg1;
		Arg2 m_arg2;
		Return* m_placeReturn;
};

// Specialization for const member function with 3 arguments and a return
template <
	typename Class,
	typename Arg1, typename Arg2, typename Arg3,
	typename Return
>
class ThreadTask<Return (Class::*)(Arg1, Arg2, Arg3) const> : public IThreadTask
{
	public:
		ThreadTask(const Class& instance, Return (Class::*function)(Arg1, Arg2, Arg3) const, Arg1 arg1, Arg2 arg2, Arg3 arg3, Return* placeReturn = NULL) :
			m_instance(instance),
			m_function(function),
			m_arg1(arg1),
			m_arg2(arg2),
			m_arg3(arg3),
			m_placeReturn(placeReturn)
		{};
		~ThreadTask() {};
		ThreadTask(const ThreadTask& copy) :
			m_instance(copy.m_instance),
			m_function(copy.m_function),
			m_arg1(copy.m_arg1),
			m_arg2(copy.m_arg2),
			m_arg3(copy.m_arg3),
			m_placeReturn(copy.m_placeReturn)
		{};
		ThreadTask& operator=(const ThreadTask& assign)
		{
			if (this == &assign)
				return (*this);
			*this = assign;
			return (*this);
		}

		void execute() const
		{
			if (!m_function) return;
			if (m_placeReturn)
				*m_placeReturn = (m_instance.*m_function)(m_arg1, m_arg2, m_arg3);
			else
				(m_instance.*m_function)(m_arg1, m_arg2, m_arg3);
		}


	private:
		const Class& m_instance;
		Return (Class::*m_function)(Arg1, Arg2, Arg3) const;
		Arg1 m_arg1;
		Arg2 m_arg2;
		Arg3 m_arg3;
		Return* m_placeReturn;
};

// Specialization for const member function with 4 arguments and a return
template <
	typename Class,
	typename Arg1, typename Arg2, typename Arg3, typename Arg4,
	typename Return
>
class ThreadTask<Return (Class::*)(Arg1, Arg2, Arg3, Arg4) const> : public IThreadTask
{
	public:
		ThreadTask(const Class& instance, Return (Class::*function)(Arg1, Arg2, Arg3, Arg4) const, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Return* placeReturn = NULL) :
			m_instance(instance),
			m_function(function),
			m_arg1(arg1),
			m_arg2(arg2),
			m_arg3(arg3),
			m_arg4(arg4),
			m_placeReturn(placeReturn)
		{};
		~ThreadTask() {};
		ThreadTask(const ThreadTask& copy) :
			m_instance(copy.m_instance),
			m_function(copy.m_function),
			m_arg1(copy.m_arg1),
			m_arg2(copy.m_arg2),
			m_arg3(copy.m_arg3),
			m_arg4(copy.m_arg4),
			m_placeReturn(copy.m_placeReturn)
		{};
		ThreadTask& operator=(const ThreadTask& assign)
		{
			if (this == &assign)
				return (*this);
			*this = assign;
			return (*this);
		}

		void execute() const
		{
			if (!m_function) return;
			if (m_placeReturn)
				*m_placeReturn = (m_instance.*m_function)(m_arg1, m_arg2, m_arg3, m_arg4);
			else
				(m_instance.*m_function)(m_arg1, m_arg2, m_arg3, m_arg4);
		}


	private:
		const Class& m_instance;
		Return (Class::*m_function)(Arg1, Arg2, Arg3, Arg4) const;
		Arg1 m_arg1;
		Arg2 m_arg2;
		Arg3 m_arg3;
		Arg4 m_arg4;
		Return* m_placeReturn;
};

// Specialization for const member function with 5 arguments and a return
template <
	typename Class,
	typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
	typename Return
>
class ThreadTask<Return (Class::*)(Arg1, Arg2, Arg3, Arg4, Arg5) const> : public IThreadTask
{
	public:
		ThreadTask(const Class& instance, Return (Class::*function)(Arg1, Arg2, Arg3, Arg4, Arg5) const, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Return* placeReturn = NULL) :
			m_instance(instance),
			m_function(function),
			m_arg1(arg1),
			m_arg2(arg2),
			m_arg3(arg3),
			m_arg4(arg4),
			m_arg5(arg5),
			m_placeReturn(placeReturn)
		{};
		~ThreadTask() {};
		ThreadTask(const ThreadTask& copy) :
			m_instance(copy.m_instance),
			m_function(copy.m_function),
			m_arg1(copy.m_arg1),
			m_arg2(copy.m_arg2),
			m_arg3(copy.m_arg3),
			m_arg4(copy.m_arg4),
			m_arg5(copy.m_arg5),
			m_placeReturn(copy.m_placeReturn)
		{};
		ThreadTask& operator=(const ThreadTask& assign)
		{
			if (this == &assign)
				return (*this);
			*this = assign;
			return (*this);
		}

		void execute() const
		{
			if (!m_function) return;
			if (m_placeReturn)
				*m_placeReturn = (m_instance.*m_function)(m_arg1, m_arg2, m_arg3, m_arg4, m_arg5);
			else
				(m_instance.*m_function)(m_arg1, m_arg2, m_arg3, m_arg4, m_arg5);
		}


	private:
		const Class& m_instance;
		Return (Class::*m_function)(Arg1, Arg2, Arg3, Arg4, Arg5) const;
		Arg1 m_arg1;
		Arg2 m_arg2;
		Arg3 m_arg3;
		Arg4 m_arg4;
		Arg5 m_arg5;
		Return* m_placeReturn;
};


#endif