# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    _UniquePointersC++98DONT.txt                       :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: manuel <manuel@student.42.fr>              +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/09/14 12:51:25 by mmaria-d          #+#    #+#              #
#    Updated: 2024/10/11 17:25:16 by manuel           ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

I attempted to implement unique pointers in C++98.
The lack of support fow ownership semantics essentially means that it cannot
be clear cut who owns what.

const UniquePtr<T>& something = some unique pointers

Unique<T> steal = something

the pointer was stollen even though the source was const

Either that, or, remove all dangerous const_casts, forbid all copies for classes
that use them and the classes themselves become unusable for containers
    all demand copy constructors and in c++98 they don't allow move constructors

So now, the principle will be, who creates something, destroys it
Exception is for instance the communication socket
In reality, it is directly interconnected with the server socket.
Best to accept that construction of the listening socket will depend on a server socket
And the connection socket is the one that calls accept

Any class that calls new, will be responsible for destruction

Any class that opens an fd, closes it


And we go back to the good old raw pointers of C.




File Descriptor class will be just a place holder with virtual close()

in reality, FileDescriptor doesn't open anything, so it is not its responsibility Either
to close whatever it is.

Inserting a class instance into a vector would be nice, but since for instance in epoll
everything will be polymorphic (could be a listening socket, connection socket, pipe reads, etc)
I can't really add it (with all the good advantages of locality as a vector would have its data close together)
Templates would also require multiple vectors of each template type, not really feasible.
