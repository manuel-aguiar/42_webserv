/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ThreadTask_NonMemb_Args_Return.tpp                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mmaria-d <mmaria-d@student.42lisboa.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/06 11:03:40 by mmaria-d          #+#    #+#             */
/*   Updated: 2024/09/06 14:07:10 by mmaria-d         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef THREADTASK_NONMEMB_ARGS_RETURN_TPP

# define THREADTASK_NONMEMB_ARGS_RETURN_TPP

# include <pthread.h>
# include <iostream>
# include <cstring>
# include <cassert>

# include "../Abstract/IThreadTask.hpp"
# include <vector>


/*
    Specializations for non member function that take up to 5 arguments and returns

    expansion generated by chatgpt (thanks, saved me hours.....)
*/

template <
	typename FunctionPointer
>
class ThreadTask;

template <typename Args, typename Return>
class ThreadTask<Return (*)(Args)> : public IThreadTask
{
public:
    ThreadTask(Return (*function)(Args), Args arguments, Return* placeReturn = NULL) :
        _function(function),
        _args(arguments),
        _placeReturn(placeReturn)
    {}
    ~ThreadTask() {}
    ThreadTask(const ThreadTask& copy) :
        _function(copy._function),
        _args(copy._args),
        _placeReturn(copy._placeReturn)
    {}
    ThreadTask& operator=(const ThreadTask& assign)
    {
        if (this == &assign)
            return *this;
        _function = assign._function;
        _args = assign._args;
        _placeReturn = assign._placeReturn;
        return *this;
    }

    void execute() const
    {
        if (!_function)
            return;
        if (_placeReturn)
            *_placeReturn = (*_function)(_args);
        else
            (*_function)(_args);
    }

    IThreadTask* clone() const
    {
        return new ThreadTask(*this);
    }

private:
    Return (*_function)(Args);
    Args _args;
    Return* _placeReturn;
};




template <typename Arg1, typename Arg2, typename Return>
class ThreadTask<Return (*)(Arg1, Arg2)> : public IThreadTask
{
public:
    ThreadTask(Return (*function)(Arg1, Arg2), Arg1 arg1, Arg2 arg2, Return* placeReturn = NULL) :
        _function(function),
        _arg1(arg1),
        _arg2(arg2),
        _placeReturn(placeReturn)
    {}
    ~ThreadTask() {}
    ThreadTask(const ThreadTask& copy) :
        _function(copy._function),
        _arg1(copy._arg1),
        _arg2(copy._arg2),
        _placeReturn(copy._placeReturn)
    {}
    ThreadTask& operator=(const ThreadTask& assign)
    {
        if (this == &assign)
            return *this;
        _function = assign._function;
        _arg1 = assign._arg1;
        _arg2 = assign._arg2;
        _placeReturn = assign._placeReturn;
        return *this;
    }

    void execute() const
    {
        if (!_function)
            return;
        if (_placeReturn)
            *_placeReturn = (*_function)(_arg1, _arg2);
        else
            (*_function)(_arg1, _arg2);
    }

    IThreadTask* clone() const
    {
        return new ThreadTask(*this);
    }

private:
    Return (*_function)(Arg1, Arg2);
    Arg1 _arg1;
    Arg2 _arg2;
    Return* _placeReturn;
};






template <typename Arg1, typename Arg2, typename Arg3, typename Return>
class ThreadTask<Return (*)(Arg1, Arg2, Arg3)> : public IThreadTask
{
public:
    ThreadTask(Return (*function)(Arg1, Arg2, Arg3), Arg1 arg1, Arg2 arg2, Arg3 arg3, Return* placeReturn = NULL) :
        _function(function),
        _arg1(arg1),
        _arg2(arg2),
        _arg3(arg3),
        _placeReturn(placeReturn)
    {}
    ~ThreadTask() {}
    ThreadTask(const ThreadTask& copy) :
        _function(copy._function),
        _arg1(copy._arg1),
        _arg2(copy._arg2),
        _arg3(copy._arg3),
        _placeReturn(copy._placeReturn)
    {}
    ThreadTask& operator=(const ThreadTask& assign)
    {
        if (this == &assign)
            return *this;
        _function = assign._function;
        _arg1 = assign._arg1;
        _arg2 = assign._arg2;
        _arg3 = assign._arg3;
        _placeReturn = assign._placeReturn;
        return *this;
    }

    void execute() const
    {
        if (!_function)
            return;
        if (_placeReturn)
            *_placeReturn = (*_function)(_arg1, _arg2, _arg3);
        else
            (*_function)(_arg1, _arg2, _arg3);
    }

    IThreadTask* clone() const
    {
        return new ThreadTask(*this);
    }

private:
    Return (*_function)(Arg1, Arg2, Arg3);
    Arg1 _arg1;
    Arg2 _arg2;
    Arg3 _arg3;
    Return* _placeReturn;
};


template <typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Return>
class ThreadTask<Return (*)(Arg1, Arg2, Arg3, Arg4)> : public IThreadTask
{
public:
    ThreadTask(Return (*function)(Arg1, Arg2, Arg3, Arg4), Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Return* placeReturn = NULL) :
        _function(function),
        _arg1(arg1),
        _arg2(arg2),
        _arg3(arg3),
        _arg4(arg4),
        _placeReturn(placeReturn)
    {}
    ~ThreadTask() {}
    ThreadTask(const ThreadTask& copy) :
        _function(copy._function),
        _arg1(copy._arg1),
        _arg2(copy._arg2),
        _arg3(copy._arg3),
        _arg4(copy._arg4),
        _placeReturn(copy._placeReturn)
    {}
    ThreadTask& operator=(const ThreadTask& assign)
    {
        if (this == &assign)
            return *this;
        _function = assign._function;
        _arg1 = assign._arg1;
        _arg2 = assign._arg2;
        _arg3 = assign._arg3;
        _arg4 = assign._arg4;
        _placeReturn = assign._placeReturn;
        return *this;
    }

    void execute() const
    {
        if (!_function)
            return;
        if (_placeReturn)
            *_placeReturn = (*_function)(_arg1, _arg2, _arg3, _arg4);
        else
            (*_function)(_arg1, _arg2, _arg3, _arg4);
    }

    IThreadTask* clone() const
    {
        return new ThreadTask(*this);
    }

private:
    Return (*_function)(Arg1, Arg2, Arg3, Arg4);
    Arg1 _arg1;
    Arg2 _arg2;
    Arg3 _arg3;
    Arg4 _arg4;
    Return* _placeReturn;
};

template <typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Return>
class ThreadTask<Return (*)(Arg1, Arg2, Arg3, Arg4, Arg5)> : public IThreadTask
{
public:
    ThreadTask(Return (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Return* placeReturn = NULL) :
        _function(function),
        _arg1(arg1),
        _arg2(arg2),
        _arg3(arg3),
        _arg4(arg4),
        _arg5(arg5),
        _placeReturn(placeReturn)
    {}
    ~ThreadTask() {}
    ThreadTask(const ThreadTask& copy) :
        _function(copy._function),
        _arg1(copy._arg1),
        _arg2(copy._arg2),
        _arg3(copy._arg3),
        _arg4(copy._arg4),
        _arg5(copy._arg5),
        _placeReturn(copy._placeReturn)
    {}
    ThreadTask& operator=(const ThreadTask& assign)
    {
        if (this == &assign)
            return *this;
        _function = assign._function;
        _arg1 = assign._arg1;
        _arg2 = assign._arg2;
        _arg3 = assign._arg3;
        _arg4 = assign._arg4;
        _arg5 = assign._arg5;
        _placeReturn = assign._placeReturn;
        return *this;
    }

    void execute() const
    {
        if (!_function)
            return;
        if (_placeReturn)
            *_placeReturn = (*_function)(_arg1, _arg2, _arg3, _arg4, _arg5);
        else
            (*_function)(_arg1, _arg2, _arg3, _arg4, _arg5);
    }

    IThreadTask* clone() const
    {
        return new ThreadTask(*this);
    }

private:
    Return (*_function)(Arg1, Arg2, Arg3, Arg4, Arg5);
    Arg1 _arg1;
    Arg2 _arg2;
    Arg3 _arg3;
    Arg4 _arg4;
    Arg5 _arg5;
    Return* _placeReturn;
};

#endif