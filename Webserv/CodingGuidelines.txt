# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    CodingGuidelines.txt                               :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: manuel <manuel@student.42.fr>              +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/11/18 09:01:59 by codespace         #+#    #+#              #
#    Updated: 2024/11/28 17:18:46 by manuel           ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

general:
	- stick more or less to norminette in terms of formatting, no limits on function sizes
	but be reasonable

	- Use stl instead of toolkit (toolkit is not complete or tested thoroughly)

	- use assert() instead of null-checks (responsibility of the caller to not pass null)
	let the program crash, in production we compile with NDEBUG (see Webserv/Makefile)

	- if you dont really need to use an exception, don't use an exception

	- NO IMPLEMENTATIONS IN HEADER FILES EXCEPT FOR TEMPLATES
		-> avoids include mess

	- global variables as in norminette: prefix with "g_" for clarity (nginx has a lot of globals and you need to check manually that they are...)
	(think if they are really necessary. If the are needed across the project, consider adding them the "Globals" class)

	- enums, prefix with "e_", typedefs prefix with "t_" etc, unions wiith "u_", norminette style

	- use your 42 header, looks nice

	- {
		Use a single folder for a class: .hpp, .cpp, .tpp, helpers....

		Separating incs from srcs means i need to check the declaration in one place and jump around
		somewhere else to find the implementation -> no, keep it together as in:

			/Class/Class.hpp					// Class declaration
			/Class/Class.cpp 					// class implementation
			/Class/ClassHelperFunctions.cpp		// some helper function you may need
			/Class/ClassSomeOtherStuff.cpp		// some other functions you may need
			/Class/ClassGetterSetters.cpp		// getters and setters bloat easily....

			- doesn't have to be like the above, what matters is all files related to a class belong
			to a folder named after that class
			- Class nesting is also okay for composition, like:

			/ServerManager/ConnectionManager/ConnectionManager.hpp
			/ServerManager/ConnectionManager/ConnectionManager.cpp
			/ServerManager/ServerManager.hpp
			/ServerManager/ServerManager.cpp



			Potentially, add a text file explaining important concepts/decisions you took when implementing
			class methods.
			Not sure of a naming convention but something like _ServerManager.docs (_ just to place it away from
			actual code). We will check later how to compile documentation.
			You can also document the functions with @ and stuff for intelisense in vscode
	}


c++:
	- if you know the size of something, use std::vector::reserve(size) or std::string::reserve(size)
		don't pushback one by one, triggers unnecessary reallocations in this case

.hpp files (class declarations):

	- Each file includes all header dependencies
	Please separate C headers from C++ headers, and maybe add a comment like:

	// C headers
	# include <unistd.h>
	# include <fcntl.h>

	// C++ Headers
	# include <exception>
	# include <stdexcept>
	# include <cstring>
	# include <string>
	# include <cerrno>

	- When including files other than std libraries, specify the actual path in the filesystem:
		#include "../Globals/Globals.hpp"
		- don't rely on the compiler to link correctly

	- camel case variable names
	- private variables prefix with "m_"

				private:
					std::string m_name;

	- private functions prefix with "mf_"

				private:
					void mf_doSomething();

	- object canonical form for classes


	global class private member: prefix with "gm_"
	global class private function: prefix with "gmf_"
		you get the idea:
			scope | privacy | variable 		<- IN THIS ORDER

.cpp (class implementations)
	NO ONE LINERS except for getters and setters, maybe constructor/destructors, let's be reasonable


.h files:
	for non-class includes
	- clearly separates class files and non-class files


Throughout the code you may want ask access to a member of a class with the intent of changing it ->
	Like a Listening Socket accessing a state manager like the EventManager or ConnectionManager, so you would return
	a non-const& from such a call.
	Therefore, give different names depending on whether you want to provide a read only reference or
	access for changing the object pointed to by the object:

		const Variable& getVariable() const; 	// return a const reference to Variable (the underlying varuiable is read Only)
		Variable& accessVariable(); 			// return a non-const reference to Variable (the caller is expected to change its state)


		get -> in the traditional OOP sense, read-only the object pointed to by the reference
		access -> explicitely breaks encapsulation, read and WRITE the object pointed to by the reference


	"Ok, so why not make those public" Probably right..................................
