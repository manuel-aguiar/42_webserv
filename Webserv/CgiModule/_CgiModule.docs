# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    _CgiModule.docs                                    :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: mmaria-d <mmaria-d@student.42lisboa.com    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/11/22 10:50:43 by manuel            #+#    #+#              #
#    Updated: 2024/12/19 11:37:52 by mmaria-d         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

The CgiModule executes CGI requests.


*****************************************************************************
Handling requests:

CgiModule::acquireRequestData
	-> internally creates a CgiRequestData and gives it to the caller

	The caller must fill the CgiRequestData with the relevant data required to execute
	the Cgi request (see CgiRequestData/_CgiRequestData.docs) using the provided setters.

*************


CgiModule::executeRequest(CgiRequestData& data)
	-> queues up the request data in the CgiModule internal data structures and executes when possible
	(when there are executors available)

**************

CgiModule::cancelRequest(CgiRequestData& data)
	-> this serves to cancel a request that was already created.
	-> if it is executing, it stops the execution (kills underlying fork)
	-> deletes the CgiRequestData
		from the CgiModule internal data structures
	
	This will be usefull for instance if the client disconnects from the server, HttpConnection
	calls this to cancel a potentially already running request.


**********************************************************


Managing interpreters:

CgiModule::addInterpreter(const std::string& extension, const std::string& path)
	-> which takes an extension (eg "py"), and an absolute path to the interpreter (eg "/usr/bin/python3")
	-> Note: the same extension cannot be executed by different interpreters. the last call to addInterpreter
	for a given extension will be the one used for execution.

**********

CgiModule::removeInterpreter(const std::string& extension);
	-> removes the target interpreter by providing the extension it executes, as key
		

*************************************
************************************
**************************************




Internally, CgiModule has a private class InternalCgiWorker that is responsible for the actual execution.

CgiModule also has a private InternalCgiRequestData to access CgiRequestData protected constructors to make
it clear that CgiRequestData cannot be spawned but must be asked for to the CgiModule via
CgiModule::acquireRequestData.




Request for CGI,
	prepare environment variables
	get an available slot
		if not, put in queue
	set in and out pipes, place them in the eventmanager, fork
	ready to write, write message body into pipe
	ready to read, read message body
	received end of file, waitpid, mark slot as available

	wait for Connection write event (to client)
		write to Client.


Again the design has the objective of maintaining flexibility. The CgiModule knows nothing about http
in reality, it could be used by any protocol as long as they provide valid event handlers, and a valid
event manager.