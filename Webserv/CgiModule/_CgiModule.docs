# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    _CgiModule.docs                                    :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: mmaria-d <mmaria-d@student.42lisboa.com    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/11/22 10:50:43 by manuel            #+#    #+#              #
#    Updated: 2024/12/18 09:17:30 by mmaria-d         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #


The CgiModule executes CGI requests. The way to interact with it is to acquire
a CgiRequestData instance via CgiModule::acquireRequestData.

The user must fill the CgiRequestData with the relevant data required to execute
the Cgi request (see CgiRequestData/_CgiRequestData.docs) using the provided setters.

The user the must call CgiModule::executeRequest(CgiRequestData) to queue the request
in CgiModule's internals for execution.

Setup:
	To execute scripts, the CgiModule needs to be correctly configured by adding interpreters
	to it via:
		CgiModule::addInterpreter()
		which takes an extension (eg "py"), and an absolute path to the interpreter (eg "/usr/bin/python3")
	Note: the same extension cannot be executed by different interpreters. the last call to addInterpreter
	for a given extension will be the one executed.


Internally, CgiModule has a private class CgiLiveRequest that is responsible for the actual execution.

CgiModule also has a private ManagedRequestData to access CgiRequestData protected constructors to make
it clear that CgiRequestData cannot be spawned but must be asked for to the CgiModule via
CgiModule::acquireRequestData.




Request for CGI,
	prepare environment variables
	get an available slot
		if not, put in queue
	set in and out pipes, place them in the eventmanager, fork
	ready to write, write message body into pipe
	ready to read, read message body
	received end of file, waitpid, mark slot as available

	wait for Connection write event (to client)
		write to Client.


A request is always start as a CgiPendingRequest, where the environment variables are setup.
That pending request will  become live if there is a slot available to do all the fork process

An outsider interacting with the CgiModule will have to pass it a valid CgiRequestData class instance
with all the data required to perform the CgiTask.


The caller will have to call CgiModule::addRequestData(const CgiRequestData& data);


Then it will try to execute it and, if there are no CgiLiveRequest slots to handle, it will be stored



Again the design has the objective of maintaining flexibility. The CgiModule knows nothing about http
in reality, it could be used by any protocol as long as they provide valid event handlers, and a valid
event manager.